<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>em-odp: Events</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doc-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">em-odp
   &#160;<span id="projectnumber">2.5.0</span>
   </div>
   <div id="projectbrief">Event Machine on ODP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/d33/group__em__event.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Events</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga15a17cee0e5de5062e78f7db2b836761"><td class="memItemLeft" align="right" valign="top">em_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc</a> (size_t size, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> type, em_pool_t pool)</td></tr>
<tr class="separator:ga15a17cee0e5de5062e78f7db2b836761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70f9fa41ada57fdaccf5212cef36c749"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga70f9fa41ada57fdaccf5212cef36c749">em_alloc_multi</a> (em_event_t events[], int num, size_t size, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> type, em_pool_t pool)</td></tr>
<tr class="separator:ga70f9fa41ada57fdaccf5212cef36c749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f97ba217518d967f8078c56023c4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free</a> (em_event_t event)</td></tr>
<tr class="separator:gad4f97ba217518d967f8078c56023c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd19ce4c6fd2e02f055eb464ba3b047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gacdd19ce4c6fd2e02f055eb464ba3b047">em_free_multi</a> (const em_event_t events[], int num)</td></tr>
<tr class="separator:gacdd19ce4c6fd2e02f055eb464ba3b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4584a01b71429dfbb045342454b464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send</a> (em_event_t event, em_queue_t queue)</td></tr>
<tr class="separator:gaca4584a01b71429dfbb045342454b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272587cb3a55dd241332fd13b6e19054"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga272587cb3a55dd241332fd13b6e19054">em_send_multi</a> (const em_event_t events[], int num, em_queue_t queue)</td></tr>
<tr class="separator:ga272587cb3a55dd241332fd13b6e19054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f701c3a5901fc81d922b9d1d02691e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer</a> (em_event_t event)</td></tr>
<tr class="separator:ga8f701c3a5901fc81d922b9d1d02691e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340201d520d7842919e7e3d9c4a6e114"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga340201d520d7842919e7e3d9c4a6e114">em_event_get_size</a> (em_event_t event)</td></tr>
<tr class="separator:ga340201d520d7842919e7e3d9c4a6e114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a1f77b8cd188c0d37cb1941a55f1b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga91a1f77b8cd188c0d37cb1941a55f1b1">em_event_set_type</a> (em_event_t event, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> newtype)</td></tr>
<tr class="separator:ga91a1f77b8cd188c0d37cb1941a55f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab47111801094f57ba20c0bc1e8d3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gaaab47111801094f57ba20c0bc1e8d3b7">em_event_get_type</a> (em_event_t event)</td></tr>
<tr class="separator:gaaab47111801094f57ba20c0bc1e8d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737794b2272daa2c771db51bdf63184f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga737794b2272daa2c771db51bdf63184f">em_event_get_type_multi</a> (const em_event_t events[], int num, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> types[])</td></tr>
<tr class="separator:ga737794b2272daa2c771db51bdf63184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4a335c1c16ed3dbae5689e614dc51b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga1f4a335c1c16ed3dbae5689e614dc51b">em_event_same_type_multi</a> (const em_event_t events[], int num, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> *same_type)</td></tr>
<tr class="separator:ga1f4a335c1c16ed3dbae5689e614dc51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b0fa0ab1252e038328e0d63c0d4dc04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send</a> (em_event_t event, em_queue_t queue)</td></tr>
<tr class="separator:ga6b0fa0ab1252e038328e0d63c0d4dc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9902e6d7b9d936a1c9b8a053176fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send</a> (em_event_t event)</td></tr>
<tr class="separator:ga4f9902e6d7b9d936a1c9b8a053176fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Operations on an event.</p>
<p>All application processing is driven by events in the Event Machine. An event describes a piece of work. The structure of an event is implementation and event type specific: it may be a directly accessible buffer of memory, a descriptor containing a list of buffer pointers, a descriptor of a packet buffer etc.</p>
<p>Applications use the event type to interpret the event structure.</p>
<p>Events follow message passing semantics: an event has to be allocated using the provided API (<a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc()</a>) or received through queues by an EO callback function after which the event is owned by the application. Event ownership is transferred back to the system by using <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> or <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>. An event not owned by the application should not be touched.</p>
<p>Since em_event_t may not carry a direct pointer value to the event structure, <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a> must be used to translate an event to an event structure pointer (for maintaining portability).</p>
<p>em_event_t is defined in <a class="el" href="../../d4/d11/event__machine__types_8h.html">event_machine_types.h</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga15a17cee0e5de5062e78f7db2b836761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a17cee0e5de5062e78f7db2b836761">&#9670;&nbsp;</a></span>em_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_event_t em_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_pool_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate an event.</p>
<p>The memory address of the allocated event is system specific and can depend on the given pool, event size and type. The returned event (handle) may refer to a memory buffer or a HW specific descriptor, i.e. the event structure is system specific.</p>
<p>Use <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a> to convert an event (handle) to a pointer to an event structure.</p>
<p>EM_EVENT_TYPE_SW with minor type '0' is reserved for direct portability - it is always guaranteed to produce an event with contiguous payload that can directly be used by the application up to the given size (no HW specific descriptors etc. are visible). This event payload will be 64-bit aligned by default (unless explicitly configured otherwise).</p>
<p>EM_POOL_DEFAULT can be used as a pool handle if there's no need to use a specific event pool (up to the size- or event limits of that pool).</p>
<p>Additionally it is guaranteed, that two separate buffers never share a cache line (to avoid false sharing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Event size in octets (size &gt; 0) </td></tr>
    <tr><td class="paramname">type</td><td>Event type to allocate </td></tr>
    <tr><td class="paramname">pool</td><td>Event pool handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated event or EM_EVENT_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>, <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a>, <a class="el" href="../../d8/d5f/group__em__eo.html#ga63161b6f46fb08a1708bad6c1fde2622">em_receive_func_t()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a24">atomic_processing_end.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a35">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a24">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a27">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a6">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a22">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a27">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a33">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a33">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a24">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a20">pairs.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a29">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a37">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a32">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a37">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a23">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a23">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a29">queues_unscheduled.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a29">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a32">timer_hello.c</a>, and <a class="el" href="../../dd/d10/timer_test_8c-example.html#a41">timer_test.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00034">34</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga70f9fa41ada57fdaccf5212cef36c749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70f9fa41ada57fdaccf5212cef36c749">&#9670;&nbsp;</a></span>em_alloc_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_alloc_multi </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_pool_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate multiple events.</p>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc()</a>, but allows allocation of multiple events, with same properties, with one function call. The <a class="el" href="../../d5/d33/group__em__event.html#ga70f9fa41ada57fdaccf5212cef36c749">em_alloc_multi()</a> API function will try to allocate the requested number ('num') of events but may fail to do so, e.g. if the pool has run out of events, and will return the actual number of events that were successfully allocated from the given pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Output event array, events are allocated and filled by <a class="el" href="../../d5/d33/group__em__event.html#ga70f9fa41ada57fdaccf5212cef36c749">em_alloc_multi()</a>. The given array must fit 'num' events. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of events to allocate and write into 'events[]' </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Event size in octets (size &gt; 0) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Event type to allocate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Event pool handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events actually allocated from the pool (0 ... num) and written into the output array 'events[]'. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00082">82</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga340201d520d7842919e7e3d9c4a6e114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga340201d520d7842919e7e3d9c4a6e114">&#9670;&nbsp;</a></span>em_event_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t em_event_get_size </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the given event</p>
<p>The event content is not defined by the OpenEM API, thus this returns an event type specific value (the exception and a defined case is EM_EVENT_TYPE_SW + minor 0, in which case the usable size of the allocated contiguous memory buffer is returned).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event type specific value typically payload size (bytes). </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d6/d76/queues_8c-example.html#a40">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a41">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a32">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a32">send_multi.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00503">503</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gaaab47111801094f57ba20c0bc1e8d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaab47111801094f57ba20c0bc1e8d3b7">&#9670;&nbsp;</a></span>em_event_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> em_event_get_type </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the event type of an event</p>
<p>Returns the type of the given event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event type, EM_EVENT_TYPE_UNDEF on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00553">553</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga737794b2272daa2c771db51bdf63184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga737794b2272daa2c771db51bdf63184f">&#9670;&nbsp;</a></span>em_event_get_type_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_event_get_type_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>types</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the event types of multiple events</p>
<p>Writes the event type of each given event into an output type-array and returns the number of entries written. Note, if 'events[num]' are all of the same type then 'types[num]' will contain 'num' same entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">events</td><td>Event handles: events[num] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">types</td><td>Event types (output array): types[num] (types[i] is the type of events[i]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of events and output types. The array 'events[]' must contain 'num' entries and the output array 'types[]' must have room for 'num' entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of event types (0...num) written into 'types[]'. The return value (always &gt;=0) is usually 'num' and thus '&lt;num' is only seen in error scenarios when the type of event[i] could not be obtained. The return value will be '0' in error cases or if the given 'num=0'. The function stops and returns on the first error and will not fill the rest of 'types[]'. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00574">574</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga6b0fa0ab1252e038328e0d63c0d4dc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b0fa0ab1252e038328e0d63c0d4dc04">&#9670;&nbsp;</a></span>em_event_mark_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_mark_send </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark the event as "sent".</p>
<p>Indicates a user-given promise to EM that the event will later appear into 'queue' by some means other than an explicit user call to em_send...(). Calling <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a> transfers event ownership away from the user, and thus the event must not be used or touched by the user anymore (the only exception is (hw) error recovery where the "sent" state can be cancelled by using <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> - dangerous!).</p>
<p>Example use case: A user provided output-callback function associated with a queue of type 'EM_QUEUE_TYPE_OUTPUT' can use this API when configuring a HW-device to deliver the event back into EM. The HW will eventually "send" the event and it will "somehow" again appear into EM for the user to process.</p>
<p>EM will, after this API-call, treat the event as "sent" and any further API operations or usage might lead to EM errors (depending on the error-check level), e.g. em_send/free/tmo_set/ack(event) etc. is forbidden after em_event_mark_send(event).</p>
<dl class="section note"><dt>Note</dt><dd>Registered API-callback hooks for em_send...() (em_api_hook_send_t) will NOT be called. </dd>
<dd>
Marking an event "sent" with an event group (corresponding to <a class="el" href="../../d8/d4c/group__em__event__group.html#gab1ecab5cd71642d3909ffb6a907fd9a5">em_send_group()</a>) is currrently NOT supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be marked as "sent" </td></tr>
    <tr><td class="paramname">queue</td><td>Destination queue (must be scheduled, i.e. atomic, parallel or parallel-ordered)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00653">653</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga8f701c3a5901fc81d922b9d1d02691e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f701c3a5901fc81d922b9d1d02691e3">&#9670;&nbsp;</a></span>em_event_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* em_event_pointer </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the event structure</p>
<p>Returns a pointer to the event structure or NULL. The event structure is implementation and event type specific. It may be a directly accessible buffer of memory, a descriptor containing a list of buffer pointers, a descriptor of a packet buffer, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event from receive/alloc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event pointer or NULL </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a27">atomic_processing_end.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a38">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a27">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a30">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a9">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a25">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a30">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a35">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a36">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a27">ordered.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a32">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a40">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a35">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a40">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a26">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a26">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a33">queues_unscheduled.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a33">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a35">timer_hello.c</a>, and <a class="el" href="../../dd/d10/timer_test_8c-example.html#a44">timer_test.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00469">469</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga1f4a335c1c16ed3dbae5689e614dc51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4a335c1c16ed3dbae5689e614dc51b">&#9670;&nbsp;</a></span>em_event_same_type_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_event_same_type_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> *&#160;</td>
          <td class="paramname"><em>same_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of events that have the same event type.</p>
<p>Returns the number of consecutive events from the start of the array 'events[]' that have the same event type. Outputs that same event type. Useful for iterating through an event-array and grouping by event type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">events</td><td>Event handles: events[num] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of events. The array 'events[]' must contain 'num' entries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">same_type</td><td>Event type pointer for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of consecutive events (0...num) with the same event type (return value always &gt;=0), includes and starts from events[0]. The return value is usually '&gt;=1' and thus '0' is only seen in error scenarios when the type of the first event could not be obtained or if the given 'num=0'. The function stops and returns on the first error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00613">613</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga91a1f77b8cd188c0d37cb1941a55f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91a1f77b8cd188c0d37cb1941a55f1b1">&#9670;&nbsp;</a></span>em_event_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_set_type </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>newtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the event type of an event</p>
<p>This will not create a new event but the existing event might be modified. The operation may fail if the new type is not compatible with the old one. As event content is not defined by the OpenEM API the compatibility is system specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramname">newtype</td><td>New type for the event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00533">533</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga4f9902e6d7b9d936a1c9b8a053176fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9902e6d7b9d936a1c9b8a053176fea">&#9670;&nbsp;</a></span>em_event_unmark_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_unmark_send </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmark an event previously marked as "sent" (i.e mark as "unsent")</p>
<dl class="section note"><dt>Note</dt><dd>This is for recovery situations only and can potenially crash the application if used incorrectly!</dd></dl>
<p>Revert an event's "sent" state, as set by <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a>, back to the state before that function call. Any further usage of the event after <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a>, by EM or the user, will result in error when calling <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> since the state has become unrecoverable. =&gt; the only allowed EM API call after <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a> is <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> if it is certain that the event, due to some external error, will never be sent into EM again otherwise. Calling <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> transfers event ownership back to the user again.</p>
<dl class="section note"><dt>Note</dt><dd>This is the only valid case of using an event that the user no longer owns - all other such uses leads to fatal error.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> err;</div><div class="line">hw_err_t hw_err;</div><div class="line"></div><div class="line"><span class="comment">// &#39;event&#39; owned by the user</span></div><div class="line">err = <a class="code" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send</a>(event, queue);</div><div class="line"><span class="keywordflow">if</span> (err != <a class="code" href="../../d4/d11/event__machine__types_8h.html#a03546e6a7e93665c52d479831e0a6dca">EM_OK</a>)</div><div class="line">   <span class="keywordflow">return</span> err; <span class="comment">// NOK</span></div><div class="line"><span class="comment">// &#39;event&#39; no longer owned by the user - don&#39;t touch!</span></div><div class="line"></div><div class="line">hw_err = config_hw_to_send_event(...hw-cfg..., event, queue);</div><div class="line"><span class="keywordflow">if</span> (hw_err) {</div><div class="line">   <span class="comment">// hw config error - the event can be recovered if it is</span></div><div class="line">   <span class="comment">// certain that the hw won&#39;t send that same event.</span></div><div class="line">   <span class="comment">// note: the user doesn&#39;t own the event here and actually</span></div><div class="line">   <span class="comment">//       uses an obsolete event handle to recover the event...</span></div><div class="line">   err = <a class="code" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send</a>(event);</div><div class="line">   <span class="keywordflow">if</span> (err != <a class="code" href="../../d4/d11/event__machine__types_8h.html#a03546e6a7e93665c52d479831e0a6dca">EM_OK</a>)</div><div class="line">       <span class="keywordflow">return</span> err; <span class="comment">// NOK</span></div><div class="line">   <span class="comment">// &#39;event&#39; recovered, again owned by the user</span></div><div class="line">   <a class="code" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free</a>(event);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event previously marked as "sent" with <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a>, any other case will be invalid!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00679">679</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gad4f97ba217518d967f8078c56023c4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f97ba217518d967f8078c56023c4d4">&#9670;&nbsp;</a></span>em_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_free </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an event.</p>
<p>The <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> function transfers ownership of the event back to the system and the application must not touch the event (or related memory buffers) after calling it.</p>
<p>It is assumed that the implementation can detect the event pool that the event was originally allocated from.</p>
<p>The application must only free events it owns. For example, the sender must not free an event after sending it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc()</a>, <a class="el" href="../../d8/d5f/group__em__eo.html#ga63161b6f46fb08a1708bad6c1fde2622">em_receive_func_t()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a36">atomic_processing_end.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a42">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a37">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a45">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a17">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a44">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a44">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a29">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a41">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a32">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a29">pairs.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a41">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a48">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a49">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a51">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a29">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a30">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a25">queues_unscheduled.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a25">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a57">timer_hello.c</a>, and <a class="el" href="../../dd/d10/timer_test_8c-example.html#a60">timer_test.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00144">144</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gacdd19ce4c6fd2e02f055eb464ba3b047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd19ce4c6fd2e02f055eb464ba3b047">&#9670;&nbsp;</a></span>em_free_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_free_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free multiple events.</p>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>, but allows freeing of multiple events with one function call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>Array of events to be freed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>The number of events in the array 'events[]' </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a35">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a35">send_multi.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00171">171</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gaca4584a01b71429dfbb045342454b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4584a01b71429dfbb045342454b464">&#9670;&nbsp;</a></span>em_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_send </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an event to a queue.</p>
<p>The event must have been allocated with <a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc()</a>, or received via an EO receive-function. The sender must not touch the event after calling <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> as the ownership has been transferred to the system or possibly to the next receiver. If the return status is <em>not</em> EM_OK, the ownership has not been transferred and the application is still responsible for the event (e.g. may free it).</p>
<p>EM does not currently define guaranteed event delivery, i.e. EM_OK return value only means the event was accepted for delivery. It could still be lost during delivery (e.g. due to a removed queue or system congestion, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be sent </td></tr>
    <tr><td class="paramname">queue</td><td>Destination queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful (accepted for delivery).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga15a17cee0e5de5062e78f7db2b836761">em_alloc()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a28">atomic_processing_end.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a39">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a28">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a31">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a38">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a26">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a31">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a52">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a37">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a28">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a30">pairs.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a59">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a47">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a36">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a41">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a27">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a28">queues_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a31">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a31">send_multi.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00213">213</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga272587cb3a55dd241332fd13b6e19054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272587cb3a55dd241332fd13b6e19054">&#9670;&nbsp;</a></span>em_send_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_send_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send multiple events to a queue.</p>
<p>As em_send, but multiple events can be sent with one call for potential performance gain. The function returns the number of events actually sent. A return value equal to the given 'num' means that all events were sent. A return value less than 'num' means that only the first 'num' events were sent and the rest must be handled by the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>Array of events to send </td></tr>
    <tr><td class="paramname">num</td><td>Number of events. The array 'events[]' must contain 'num' entries. </td></tr>
    <tr><td class="paramname">queue</td><td>Destination queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of events successfully sent (equal to num if all successful)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a35">atomic_processing_end.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a45">fractal.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a34">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a23">pairs.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a47">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a49">queue_types_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a34">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a34">send_multi.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00362">362</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
  <div id="footer" class="tabs">
   <div class="headertitle"> 
     &copy; 2017 Nokia Networks
   </div>
  </div>
 </body>
</html>
